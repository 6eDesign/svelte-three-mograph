/* src/documentation/pages/Orbit.svelte generated by Svelte v3.31.2 */
import {
	SvelteComponent,
	assign,
	attr,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	run_all,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "../../../web_modules/svelte/internal.js";

import { Scene, Material, mograph, primitives } from "../../components/index.js";
import AmbientLight from "../../components/lights/AmbientLight.js";
import DirectionalLight from "../../components/lights/DirectionalLight.js";
import OrbitExample from "../../OrbitExample.js";

function create_if_block(ctx) {
	let particle;
	let current;

	particle = new /*Particle*/ ctx[3]({
			props: {
				rotationalVelocity: [0.03, 0.03, 0.03],
				$$slots: {
					default: [
						create_default_slot_1,
						({ rotation, position }) => ({ 7: rotation, 8: position }),
						({ rotation, position }) => (rotation ? 128 : 0) | (position ? 256 : 0)
					]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(particle.$$.fragment);
		},
		m(target, anchor) {
			mount_component(particle, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const particle_changes = {};

			if (dirty & /*$$scope, rotation, position*/ 896) {
				particle_changes.$$scope = { dirty, ctx };
			}

			particle.$set(particle_changes);
		},
		i(local) {
			if (current) return;
			transition_in(particle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(particle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(particle, detaching);
		}
	};
}

// (26:6) <Material color="#fff" metalness={0.5} roughness={0.65}>
function create_default_slot_2(ctx) {
	let icosahedron;
	let current;

	icosahedron = new /*Icosahedron*/ ctx[4]({
			props: {
				size: 2.2,
				rotation: /*rotation*/ ctx[7],
				position: /*position*/ ctx[8]
			}
		});

	return {
		c() {
			create_component(icosahedron.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icosahedron, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icosahedron_changes = {};
			if (dirty & /*rotation*/ 128) icosahedron_changes.rotation = /*rotation*/ ctx[7];
			if (dirty & /*position*/ 256) icosahedron_changes.position = /*position*/ ctx[8];
			icosahedron.$set(icosahedron_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icosahedron.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icosahedron.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icosahedron, detaching);
		}
	};
}

// (25:4) <Particle rotationalVelocity={[0.03, 0.03, 0.03]} let:rotation let:position>
function create_default_slot_1(ctx) {
	let material;
	let current;

	material = new Material({
			props: {
				color: "#fff",
				metalness: 0.5,
				roughness: 0.65,
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(material.$$.fragment);
		},
		m(target, anchor) {
			mount_component(material, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const material_changes = {};

			if (dirty & /*$$scope, rotation, position*/ 896) {
				material_changes.$$scope = { dirty, ctx };
			}

			material.$set(material_changes);
		},
		i(local) {
			if (current) return;
			transition_in(material.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(material.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(material, detaching);
		}
	};
}

// (19:0) <Scene background="#67727e" {width} height={450}>
function create_default_slot(ctx) {
	let ambientlight;
	let t0;
	let directionallight;
	let t1;
	let orbitexample0;
	let t2;
	let t3;
	let orbitexample1;
	let current;
	ambientlight = new AmbientLight({ props: { intensity: 2.8 } });
	directionallight = new DirectionalLight({ props: { intensity: 1.1 } });
	orbitexample0 = new OrbitExample({});
	let if_block = /*opts*/ ctx[1].includePlanet && create_if_block(ctx);
	const orbitexample1_spread_levels = [{ size: 0.06 }, /*orbitOpts*/ ctx[2]];
	let orbitexample1_props = {};

	for (let i = 0; i < orbitexample1_spread_levels.length; i += 1) {
		orbitexample1_props = assign(orbitexample1_props, orbitexample1_spread_levels[i]);
	}

	orbitexample1 = new OrbitExample({ props: orbitexample1_props });

	return {
		c() {
			create_component(ambientlight.$$.fragment);
			t0 = space();
			create_component(directionallight.$$.fragment);
			t1 = space();
			create_component(orbitexample0.$$.fragment);
			t2 = space();
			if (if_block) if_block.c();
			t3 = space();
			create_component(orbitexample1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(ambientlight, target, anchor);
			insert(target, t0, anchor);
			mount_component(directionallight, target, anchor);
			insert(target, t1, anchor);
			mount_component(orbitexample0, target, anchor);
			insert(target, t2, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, t3, anchor);
			mount_component(orbitexample1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*opts*/ ctx[1].includePlanet) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*opts*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t3.parentNode, t3);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const orbitexample1_changes = (dirty & /*orbitOpts*/ 4)
			? get_spread_update(orbitexample1_spread_levels, [orbitexample1_spread_levels[0], get_spread_object(/*orbitOpts*/ ctx[2])])
			: {};

			orbitexample1.$set(orbitexample1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(ambientlight.$$.fragment, local);
			transition_in(directionallight.$$.fragment, local);
			transition_in(orbitexample0.$$.fragment, local);
			transition_in(if_block);
			transition_in(orbitexample1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(ambientlight.$$.fragment, local);
			transition_out(directionallight.$$.fragment, local);
			transition_out(orbitexample0.$$.fragment, local);
			transition_out(if_block);
			transition_out(orbitexample1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(ambientlight, detaching);
			if (detaching) detach(t0);
			destroy_component(directionallight, detaching);
			if (detaching) detach(t1);
			destroy_component(orbitexample0, detaching);
			if (detaching) detach(t2);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t3);
			destroy_component(orbitexample1, detaching);
		}
	};
}

function create_fragment(ctx) {
	let scene;
	let t0;
	let input0;
	let t1;
	let input1;
	let current;
	let mounted;
	let dispose;

	scene = new Scene({
			props: {
				background: "#67727e",
				width: /*width*/ ctx[0],
				height: 450,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(scene.$$.fragment);
			t0 = space();
			input0 = element("input");
			t1 = space();
			input1 = element("input");
			attr(input0, "type", "checkbox");
			attr(input1, "type", "checkbox");
		},
		m(target, anchor) {
			mount_component(scene, target, anchor);
			insert(target, t0, anchor);
			insert(target, input0, anchor);
			input0.checked = /*orbitOpts*/ ctx[2].addPointLights;
			insert(target, t1, anchor);
			insert(target, input1, anchor);
			input1.checked = /*opts*/ ctx[1].includePlanet;
			current = true;

			if (!mounted) {
				dispose = [
					listen(input0, "change", /*input0_change_handler*/ ctx[5]),
					listen(input1, "change", /*input1_change_handler*/ ctx[6])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const scene_changes = {};
			if (dirty & /*width*/ 1) scene_changes.width = /*width*/ ctx[0];

			if (dirty & /*$$scope, orbitOpts, opts*/ 518) {
				scene_changes.$$scope = { dirty, ctx };
			}

			scene.$set(scene_changes);

			if (dirty & /*orbitOpts*/ 4) {
				input0.checked = /*orbitOpts*/ ctx[2].addPointLights;
			}

			if (dirty & /*opts*/ 2) {
				input1.checked = /*opts*/ ctx[1].includePlanet;
			}
		},
		i(local) {
			if (current) return;
			transition_in(scene.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(scene.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(scene, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(input0);
			if (detaching) detach(t1);
			if (detaching) detach(input1);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const { Particle } = mograph;
	const { Icosahedron } = primitives;
	let { width } = $$props;
	const opts = { includePlanet: true };
	const orbitOpts = { radius: 2.5, addPointLights: true };

	function input0_change_handler() {
		orbitOpts.addPointLights = this.checked;
		$$invalidate(2, orbitOpts);
	}

	function input1_change_handler() {
		opts.includePlanet = this.checked;
		$$invalidate(1, opts);
	}

	$$self.$$set = $$props => {
		if ("width" in $$props) $$invalidate(0, width = $$props.width);
	};

	return [
		width,
		opts,
		orbitOpts,
		Particle,
		Icosahedron,
		input0_change_handler,
		input1_change_handler
	];
}

class Orbit extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { width: 0 });
	}
}

export default Orbit;