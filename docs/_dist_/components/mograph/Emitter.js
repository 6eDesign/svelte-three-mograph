/* src/components/mograph/Emitter.svelte generated by Svelte v3.31.2 */
import {
	SvelteComponent,
	check_outros,
	create_component,
	create_slot,
	destroy_component,
	detach,
	empty,
	group_outros,
	init,
	insert,
	mount_component,
	outro_and_destroy_block,
	safe_not_equal,
	space,
	transition_in,
	transition_out,
	update_keyed_each,
	update_slot
} from "../../../web_modules/svelte/internal.js";

import { getContext } from "../../../web_modules/svelte.js";
import { Vector3 } from "../../../web_modules/three.js";
import Forces from "./Forces.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	return child_ctx;
}

const get_default_slot_changes = dirty => ({
	position: dirty & /*position*/ 2,
	rotation: dirty & /*rotation*/ 4
});

const get_default_slot_context = ctx => ({
	position: /*position*/ ctx[1],
	rotation: /*rotation*/ ctx[2]
});

// (79:2) <Forces     forces={[...forces]}     position={particle.position}     velocity={particle.velocity}     rotationalVelocity={particle.rotationalVelocity}     let:position     let:rotation   >
function create_default_slot(ctx) {
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], get_default_slot_context);

	return {
		c() {
			if (default_slot) default_slot.c();
			t = space();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, position, rotation*/ 65542) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, get_default_slot_changes, get_default_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t);
		}
	};
}

// (78:0) {#each particles as particle (particle.id)}
function create_each_block(key_1, ctx) {
	let first;
	let forces_1;
	let current;

	forces_1 = new Forces({
			props: {
				forces: [.../*forces*/ ctx[0]],
				position: /*particle*/ ctx[26].position,
				velocity: /*particle*/ ctx[26].velocity,
				rotationalVelocity: /*particle*/ ctx[26].rotationalVelocity,
				$$slots: {
					default: [
						create_default_slot,
						({ position, rotation }) => ({ 1: position, 2: rotation }),
						({ position, rotation }) => (position ? 2 : 0) | (rotation ? 4 : 0)
					]
				},
				$$scope: { ctx }
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(forces_1.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(forces_1, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const forces_1_changes = {};
			if (dirty & /*forces*/ 1) forces_1_changes.forces = [.../*forces*/ ctx[0]];
			if (dirty & /*particles*/ 8) forces_1_changes.position = /*particle*/ ctx[26].position;
			if (dirty & /*particles*/ 8) forces_1_changes.velocity = /*particle*/ ctx[26].velocity;
			if (dirty & /*particles*/ 8) forces_1_changes.rotationalVelocity = /*particle*/ ctx[26].rotationalVelocity;

			if (dirty & /*$$scope, position, rotation*/ 65542) {
				forces_1_changes.$$scope = { dirty, ctx };
			}

			forces_1.$set(forces_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(forces_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(forces_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(forces_1, detaching);
		}
	};
}

function create_fragment(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = /*particles*/ ctx[3];
	const get_key = ctx => /*particle*/ ctx[26].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*forces, particles, $$scope, position, rotation*/ 65551) {
				each_value = /*particles*/ ctx[3];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { position = [0, 0, 0] } = $$props;
	let { rotation = [0, 0, 0] } = $$props;
	let { velocity = 0.04 } = $$props;
	let { velocityVariance = 0.03 } = $$props;
	let { rotationVelocity = 0.02 } = $$props;
	let { rotationVelocityVariance = 0.008 } = $$props;
	let { size = [0, 0, 0] } = $$props;
	let { direction = [0, 0, 1] } = $$props;
	let { directionVariance = 0.5 } = $$props;
	let { rotationDirection = [0, 0, 0] } = $$props;
	let { rotationDirectionVariance = 2 } = $$props;
	let { lifespan = 15000 } = $$props;
	let { particlesPerSecond = 5 } = $$props;
	let { forces = [] } = $$props;
	const random = clamp => Math.random() * clamp * (Math.random() > 0.5 ? 1 : -1);
	const addVariance = variance => num => num + random(variance);
	const varyVelocity = addVariance(velocityVariance);
	const varyDirection = addVariance(directionVariance);
	const varyRotationVelocity = addVariance(rotationVelocityVariance);
	const varyRotationDirection = addVariance(rotationDirectionVariance);
	let particles = [];
	let particleCount = 0;

	const addParticle = () => {
		const now = Date.now();
		const particleDirection = new Vector3(...direction.map(varyDirection));
		const particleVelocity = new Vector3().addScaledVector(particleDirection, varyVelocity(velocity));
		const particleRotationalDirection = new Vector3(...rotationDirection.map(varyRotationDirection));
		const particleRotationalVelocity = new Vector3().addScaledVector(particleRotationalDirection, varyRotationVelocity(rotationVelocity));

		$$invalidate(3, particles = [
			...particles.filter(({ dies }) => now < dies),
			{
				id: particleCount,
				dies: now + lifespan,
				position: [
					addVariance(size[0] / 2)(position[0]),
					addVariance(size[1] / 2)(position[1]),
					addVariance(size[2] / 2)(position[2])
				],
				rotation,
				force: {
					direction: new Vector3(),
					rotation: new Vector3()
				},
				velocity: [particleVelocity.x, particleVelocity.y, particleVelocity.z],
				rotationalVelocity: [
					particleRotationalVelocity.x,
					particleRotationalVelocity.y,
					particleRotationalVelocity.z
				]
			}
		]);

		++particleCount;
		setTimeout(addParticle, 1000 / particlesPerSecond);
	};

	addParticle();
	const sceneCtx = getContext("sceneCtx");

	$$self.$$set = $$props => {
		if ("position" in $$props) $$invalidate(1, position = $$props.position);
		if ("rotation" in $$props) $$invalidate(2, rotation = $$props.rotation);
		if ("velocity" in $$props) $$invalidate(4, velocity = $$props.velocity);
		if ("velocityVariance" in $$props) $$invalidate(5, velocityVariance = $$props.velocityVariance);
		if ("rotationVelocity" in $$props) $$invalidate(6, rotationVelocity = $$props.rotationVelocity);
		if ("rotationVelocityVariance" in $$props) $$invalidate(7, rotationVelocityVariance = $$props.rotationVelocityVariance);
		if ("size" in $$props) $$invalidate(8, size = $$props.size);
		if ("direction" in $$props) $$invalidate(9, direction = $$props.direction);
		if ("directionVariance" in $$props) $$invalidate(10, directionVariance = $$props.directionVariance);
		if ("rotationDirection" in $$props) $$invalidate(11, rotationDirection = $$props.rotationDirection);
		if ("rotationDirectionVariance" in $$props) $$invalidate(12, rotationDirectionVariance = $$props.rotationDirectionVariance);
		if ("lifespan" in $$props) $$invalidate(13, lifespan = $$props.lifespan);
		if ("particlesPerSecond" in $$props) $$invalidate(14, particlesPerSecond = $$props.particlesPerSecond);
		if ("forces" in $$props) $$invalidate(0, forces = $$props.forces);
		if ("$$scope" in $$props) $$invalidate(16, $$scope = $$props.$$scope);
	};

	return [
		forces,
		position,
		rotation,
		particles,
		velocity,
		velocityVariance,
		rotationVelocity,
		rotationVelocityVariance,
		size,
		direction,
		directionVariance,
		rotationDirection,
		rotationDirectionVariance,
		lifespan,
		particlesPerSecond,
		slots,
		$$scope
	];
}

class Emitter extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			position: 1,
			rotation: 2,
			velocity: 4,
			velocityVariance: 5,
			rotationVelocity: 6,
			rotationVelocityVariance: 7,
			size: 8,
			direction: 9,
			directionVariance: 10,
			rotationDirection: 11,
			rotationDirectionVariance: 12,
			lifespan: 13,
			particlesPerSecond: 14,
			forces: 0
		});
	}
}

export default Emitter;